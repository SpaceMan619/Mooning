<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mooning - Vibe Coded V4</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    
    * { margin: 0; padding: 0; }
    body { 
      overflow: hidden; 
      background: #000; 
      font-family: 'Orbitron', monospace;
    }
    canvas { 
        display: block; 
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-crisp-edges;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
    }
    
    .title-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 1s ease-out;
      overflow: hidden;
    }

    #splashCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    .title-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .title {
      font-size: 72px;
      font-weight: 900;
      font-family: 'Press Start 2P', monospace;
      color: #fff;
      text-shadow: 4px 4px 0px #666;
      margin-bottom: 40px;
      letter-spacing: 8px;
      z-index: 2;
    }
    
    .subtitle {
      color: #aaa;
      font-size: 14px;
      font-family: 'Press Start 2P', monospace;
      margin-bottom: 10px;
      z-index: 2;
    }

    .credits, .start-btn { z-index: 2; }
    
    .credits {
      color: #888;
      font-size: 12px;
      font-family: 'Press Start 2P', monospace;
      margin-bottom: 60px;
      z-index: 2;
    }
    
    .start-btn {
      padding: 15px 30px;
      font-size: 16px;
      background: #000;
      color: #fff;
      border: 3px solid #fff;
      cursor: pointer;
      font-family: 'Press Start 2P', monospace;
      position: relative;
      transition: all 0.1s;
      text-transform: uppercase;
      letter-spacing: 2px;
      box-shadow: 4px 4px 0px #666;
    }
    
    .start-btn:hover {
      background: #fff;
      color: #000;
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0px #666;
    }
    
    .start-btn:active {
      transform: translate(4px, 4px);
      box-shadow: 0px 0px 0px #666;
    }
    
    @keyframes gradient {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    @keyframes glow {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.2); }
    }
    
    .retro-grid {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 50%;
      background-image: 
        linear-gradient(rgba(255,0,255,0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,0,255,0.1) 1px, transparent 1px);
      background-size: 50px 50px;
      transform: perspective(500px) rotateX(60deg);
      animation: grid-move 2s linear infinite;
      z-index: 1;
    }
    
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #0f0;
      font-family: 'Orbitron', monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border: 2px solid #0f0;
      box-shadow: 0 0 20px rgba(0,255,0,0.3);
      z-index: 10;
    }
    
    .hud div { margin: 5px 0; text-shadow: 0 0 5px rgba(0,255,0,0.5); }
    .hud .critical { color: #f00; animation: blink 0.5s infinite; }
    
    @keyframes blink { 50% { opacity: 0.5; } }
    
    .msg {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      text-align: center;
      display: none;
      z-index: 10;
      padding: 30px;
      background: rgba(0, 0, 0, 0.95);
      border: 3px solid #0f0;
      border-radius: 4px;
      box-shadow: 
        0 0 20px rgba(0, 255, 0, 0.3),
        inset 0 0 20px rgba(0, 255, 0, 0.2);
      animation: msgPulse 2s infinite;
      min-width: 400px;
      max-width: 80%;
      backdrop-filter: blur(5px);
    }
    
    @keyframes msgPulse {
      0% { border-color: #0f0; box-shadow: 0 0 20px rgba(0, 255, 0, 0.3), inset 0 0 20px rgba(0, 255, 0, 0.2); }
      50% { border-color: #0a0; box-shadow: 0 0 30px rgba(0, 255, 0, 0.4), inset 0 0 30px rgba(0, 255, 0, 0.3); }
      100% { border-color: #0f0; box-shadow: 0 0 20px rgba(0, 255, 0, 0.3), inset 0 0 20px rgba(0, 255, 0, 0.2); }
    }

    .popup-msg {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 255, 0, 0.8);
        color: #000;
        padding: 10px 20px;
        border-radius: 5px;
        font-size: 16px;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
    }
    
    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: #888;
      font-family: 'Orbitron', monospace;
      font-size: 12px;
      text-align: right;
      z-index: 10;
    }

    .sound-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #00ffff;
      font-size: 24px;
      cursor: pointer;
      z-index: 1001;
      opacity: 0.7;
      transition: opacity 0.3s;
    }
    .sound-toggle:hover { opacity: 1; }

    /* Radar CSS removed */

    .undertale-box {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      max-width: 600px;
      background: #000;
      border: 4px solid #fff;
      padding: 20px;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      color: #fff;
      line-height: 1.8;
      z-index: 2000;
      display: none;
  box-shadow: 0 0 0 4px #000, 0 0 40px rgba(255, 255, 255, 0.3);
  transition: border-color 0.3s, box-shadow 0.3s;
    }

    .undertale-box.show {
      display: block;
      animation: undertale-appear 0.3s ease-out;
    }

    @keyframes undertale-appear {
      from {
        transform: translateX(-50%) scale(0.9);
        opacity: 0;
      }
      to {
        transform: translateX(-50%) scale(1);
        opacity: 1;
      }
    }

    .undertale-text {
      display: inline;
    }

    .undertale-prompt {
      position: absolute;
      bottom: 10px;
      right: 20px;
      font-size: 10px;
      color: #888;
      animation: blink 1s infinite;
    }

    .msg.success {
      top: 20%;
      bottom: auto;
      background: rgba(0, 20, 0, 0.8);
      border: 2px solid #0f0;
      backdrop-filter: none;
      animation: none;
      min-width: 300px;
      padding: 20px;
    }

    .msg.crash {
      /* This will inherit the default .msg styles for the crash screen */
    }

    .undertale-input {
      display: inline-block;
      background: transparent;
      border: none;
      border-bottom: 2px solid #fff;
      color: #fff;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
  width: 0;
  margin-left: 0;
      padding: 4px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease, width 0.15s ease;
    }
    .undertale-input:focus {
      outline: none;
      border-bottom-color: #0f0;
    }
    .undertale-box.asking-name .undertale-input {
      width: 50%;
      margin-left: 10px;
      opacity: 1;
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <div class="title-screen" id="titleScreen">
    <canvas id="splashCanvas"></canvas>
    <div class="title">MOONING</div>
    <div class="subtitle">A lunar landing experience</div>
    <div class="credits">Created by Rajveer</div>
    <button class="start-btn" onclick="startGame()">START</button>
    <div class="sound-toggle" id="soundToggle">🔇</div>
  </div>
  
  <canvas id="c"></canvas>
  
  <div class="hud">
    <div>FUEL: <span id="fuel">100</span>%</div>
    <div>FUEL PACKS: <span id="fuelPacks">0</span></div>
    <div>ALT: <span id="alt">0</span>m</div>
    <div>V-SPEED: <span id="vspeed">0</span>m/s</div>
    <div>H-SPEED: <span id="hspeed">0</span>m/s</div>
    <div>ANGLE: <span id="angle">0</span>°</div>
  </div>
  
  <div class="msg" id="msg"></div>
  <div class="popup-msg" id="popupMsg"></div>
  
  <div class="controls" id="controls">
    W/↑ THRUST | A/D ROTATE | R RESTART | ESC MENU
  </div>

  <div class="undertale-box" id="undertaleBox">
    <div class="undertale-text" id="undertaleText"></div>
    <input type="text" class="undertale-input" id="undertaleInput" maxlength="20" />
    <div class="undertale-prompt">Press ENTER</div>
  </div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = window.innerWidth;
let H = canvas.height = window.innerHeight;

let gameState = 'title';
const SHIP_GRAVITY = 0.02;
const ASTRO_GRAVITY = 0.05;
const JUMP_FORCE = -2.5;
const MOVE_SPEED = 1.5;
// Thrust ramp parameters (simple inertia feel without complex physics)
const MAX_THRUST_POWER = 0.2;        // Existing feel at full burn
const THRUST_RAMP_UP = 0.035;        // How fast throttle approaches 1 while holding thrust
const THRUST_RAMP_DOWN = 0.08;       // How fast throttle decays when released

let ship = { x: W/2, y: 100, vx: 0, vy: 0, angle: 0, fuel: 100, thrusting: false, throttle: 0, legExtension: 0, firstLegTouchTime: null };
let astronaut = { x: 0, y: 0, vx: 0, vy: 0, w: 8, h: 16, onGround: false, visible: false, name: null };
let camera = { x: 0, y: 0 };
let terrain = [];
let fuelPickups = [];
let monolith = { x: 0, y: 0, w: 20, h: 80 };
let pad = { x: 0, y: 0, w: 120 };
const TERRAIN_WIDTH = W * 10;
const TERRAIN_POINTS = 300;

// Initialize core game state
let godModeEnabled = false;
const keySequence = [];
const GOD_MODE_SEQUENCE = 'god';
let firstLandingDone = false;
let typewriterInterval = null;
let monolithDialogueSeen = false;
let astronautNameKnown = false;
let lily = { x: 0, y: 0, picked: false };
let lilyPromptShown = false;
let stuntTracker = { lastAngle: 0, accum: 0, cooldown: 0 };

const dialogueState = {
  active: false,
  queue: [],
  index: -1,
  waitingForInput: false,
  askNameAt: null,
  afterNameLines: null,
  onComplete: null,
  context: null
};

// DIALOGUE AUTHOR NOTE:
// Use startDialogueSequence([...lines], { askNameAt, afterNameLines, onComplete })
// for every narrative beat. Keep all new behavior inside these helpers so gameplay
// loops never care about dialogue details.

function resetDialogueState() {
  dialogueState.active = false;
  dialogueState.queue = [];
  dialogueState.index = -1;
  dialogueState.waitingForInput = false;
  dialogueState.askNameAt = null;
  dialogueState.afterNameLines = null;
  dialogueState.onComplete = null;
  dialogueState.context = null;
}

function startDialogueSequence(lines, options = {}) {
  const {
    context = null,
    askNameAt = null,
    afterNameLines = null,
    onComplete = null
  } = options;

  dialogueState.active = true;
  dialogueState.queue = Array.isArray(lines) ? [...lines] : [];
  dialogueState.index = -1;
  dialogueState.waitingForInput = false;
  dialogueState.askNameAt = typeof askNameAt === 'number' ? askNameAt : null;
  dialogueState.afterNameLines = afterNameLines;
  dialogueState.onComplete = typeof onComplete === 'function' ? onComplete : null;
  dialogueState.context = context;

  showNextDialogue();
}

const landingDialogues = [
  "* The lander touches down on the dark side of the moon.",
  "* The silence is absolute.",
  "* Yet... something watches from the craters."
];

const monolithDialogues = [
  "... a signal ... faint ... leaves this place ...",
  "... another soul ... what is your designation?"
];


let splashStars = [];
let splashMoon = { y: -200, vy: 0.1 };

function setupSplashScreen() {
  const splashCanvas = document.getElementById('splashCanvas');
  const splashCtx = splashCanvas.getContext('2d');
  
  // Set initial canvas size
  splashCanvas.width = window.innerWidth;
  splashCanvas.height = window.innerHeight;

  // Create stars if they don't exist
  if (splashStars.length === 0) {
    for (let i = 0; i < 100; i++) {
      splashStars.push({
        x: Math.random() * splashCanvas.width,
        y: Math.random() * splashCanvas.height,
        size: Math.random() * 2 + 1,
        speed: Math.random() * 0.5 + 0.1
      });
    }
  }

  // Handle resize
  window.addEventListener('resize', () => {
    if (gameState === 'title') {
      splashCanvas.width = window.innerWidth;
      splashCanvas.height = window.innerHeight;
    }
  });

  function drawSplashScreen() {
    if (gameState !== 'title') return;

    splashCtx.clearRect(0, 0, splashCanvas.width, splashCanvas.height);

    // Draw stars
    splashCtx.fillStyle = 'white';
    for (const star of splashStars) {
      star.y += star.speed;
      if (star.y > splashCanvas.height) {
        star.y = 0;
        star.x = Math.random() * splashCanvas.width;
      }
      const pulse = Math.sin(Date.now() * 0.003 + star.x) * 0.2 + 0.8;
      splashCtx.globalAlpha = pulse;
      splashCtx.fillRect(star.x, star.y, star.size, star.size);
    }
    splashCtx.globalAlpha = 1;

    requestAnimationFrame(drawSplashScreen);
  }

  // Start the animation loop
  drawSplashScreen();
}


const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
let isAudioUnlocked = false;
let isMusicMuted = true;

const sounds = {
  thrust: null,
  ambience: null,
  music: null,
  crash: null,
  land: null
};

const particles = [];

function createParticle(x, y, vx, vy, color, life = 30) {
  particles.push({ x, y, vx, vy, color, life, maxLife: life });
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    p.vy += 0.05;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.fillStyle = p.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
    ctx.beginPath();
    ctx.arc(p.x, p.y, alpha * 1.5, 0, Math.PI * 2);
    ctx.fill();
  });
}

function drawRadar() {
  // Radar removed for stability
}

function unlockAudio() {
    if (!isAudioUnlocked) {
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        isAudioUnlocked = true;
        if (!isMusicMuted) {
            startTitleMusic();
        }
        document.body.removeEventListener('click', unlockAudio);
        document.body.removeEventListener('keydown', unlockAudio);
    }
}
document.body.addEventListener('click', unlockAudio);
document.body.addEventListener('keydown', unlockAudio);

function createThrustSound() {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc.type = 'sawtooth';
  osc.frequency.value = 80;
  filter.type = 'lowpass';
  filter.frequency.value = 200;
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  gain.gain.value = 0;
  osc.start();
  return { osc, gain, filter };
}

function createAmbience() {
  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc1.type = 'sine';
  osc1.frequency.value = 60;
  osc2.type = 'sine';
  osc2.frequency.value = 90;
  filter.type = 'lowpass';
  filter.frequency.value = 100;
  filter.Q.value = 15;
  osc1.connect(filter);
  osc2.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  gain.gain.value = isMusicMuted ? 0 : 0.03;
  osc1.start();
  osc2.start();
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  lfo.frequency.value = 0.2;
  lfoGain.gain.value = 10;
  lfo.connect(lfoGain);
  lfoGain.connect(filter.frequency);
  lfo.start();
  return { gain };
}

function createMusic() {
  if (isMusicMuted) return null;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc.type = 'square';
  filter.type = 'lowpass';
  filter.frequency.value = 800;
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  gain.gain.value = 0.05;
  const notes = [110, 130, 165, 130, 110, 98, 110, 130];
  let noteIndex = 0;
  function playNote() {
    osc.frequency.setValueAtTime(notes[noteIndex], audioCtx.currentTime);
    noteIndex = (noteIndex + 1) % notes.length;
  }
  osc.start();
  const interval = setInterval(playNote, 400);
  return { gain, stop: () => { clearInterval(interval); osc.stop(); } };
}

function startTitleMusic() {
  if (sounds.music || isMusicMuted) return;
  sounds.music = createMusic();
}

function stopTitleMusic() {
  if (sounds.music) {
    sounds.music.gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1);
    setTimeout(() => {
      if (sounds.music) {
        sounds.music.stop();
        sounds.music = null;
      }
    }, 1000);
  }
}

function playEffect(type) {
  if (!isAudioUnlocked || isMusicMuted) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  if (type === 'crash') {
    osc.type = 'sawtooth';
    osc.frequency.value = 50;
    filter.type = 'lowpass';
    filter.frequency.value = 500;
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);
    filter.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 1);
    for (let i = 0; i < 30; i++) {
      createParticle(ship.x, ship.y, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, 'rgb(200, 200, 200)');
    }
  } else {
    osc.type = 'sine';
    osc.frequency.value = 400;
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
    osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.5);
  }
  osc.start();
  osc.stop(audioCtx.currentTime + 1.5);
}

let stars = [];
for(let i = 0; i < 200; i++) {
  stars.push({ x: Math.random() * W, y: Math.random() * H, size: Math.random() * 2, speed: 0.1 + Math.random() * 0.3 });
}

function createMoonPattern() {
    const patternCanvas = document.createElement('canvas');
    const pCtx = patternCanvas.getContext('2d');
    const size = 64;
    const pixelSize = 2;
    patternCanvas.width = size;
    patternCanvas.height = size;

    pCtx.fillStyle = '#5a5a63';
    pCtx.fillRect(0, 0, size, size);

    const colors = ['#4a4a53', '#6a6a73', '#7a7a83', '#505059'];
    
    for (let x = 0; x < size; x += pixelSize) {
        for (let y = 0; y < size; y += pixelSize) {
            const rand = Math.random();
            if (rand > 0.6) {
                const colorIndex = Math.floor(Math.random() * colors.length);
                pCtx.fillStyle = colors[colorIndex];
                pCtx.fillRect(x, y, pixelSize, pixelSize);
            }
        }
    }
    
    for (let i = 0; i < 8; i++) {
        const x = Math.floor(Math.random() * (size / pixelSize)) * pixelSize;
        const y = Math.floor(Math.random() * (size / pixelSize)) * pixelSize;
        const craterSize = (1 + Math.floor(Math.random() * 2)) * pixelSize;
        pCtx.fillStyle = '#3a3a43';
        pCtx.fillRect(x, y, craterSize, craterSize);
    }
    
    return patternCanvas;
}

function makeTerrain() {
  terrain = [];
  fuelPickups = [];
  
  let baseHeight = H * 0.5;
  
  for(let i = 0; i <= TERRAIN_POINTS; i++) {
    let x = (TERRAIN_WIDTH / TERRAIN_POINTS) * i;
    let y = baseHeight + Math.sin(i * 0.3) * 30 + Math.sin(i * 0.7) * 20;
    terrain.push({x, y});
  }
  
  let firstY = baseHeight + Math.sin(0 * 0.3) * 30 + Math.sin(0 * 0.7) * 20;
  terrain[TERRAIN_POINTS] = { x: TERRAIN_WIDTH, y: firstY };

  for(let i = 0; i < 12; i++) {
    const pickupX = Math.random() * TERRAIN_WIDTH;
    const groundY = getGroundY(pickupX);
    fuelPickups.push({ x: pickupX, y: groundY - 10, collected: false });
  }
  
  let padIndex = Math.floor(TERRAIN_POINTS / 10);
  pad.x = terrain[padIndex].x - 60;
  pad.y = terrain[padIndex].y;
  
  for(let i = padIndex - 2; i <= padIndex + 2; i++) {
    if(terrain[i]) terrain[i].y = pad.y;
  }

  monolith.x = pad.x + pad.w + 500;
  monolith.y = getGroundY(monolith.x) - monolith.h;

  lily.x = pad.x - (pad.w + 160);
  const lilyGround = getGroundY(lily.x);
  lily.y = lilyGround;
  lily.picked = false;
  lilyPromptShown = false;
}

function showPopup(message) {
    const popup = document.getElementById('popupMsg');
    popup.textContent = message;
    popup.style.opacity = '1';
    setTimeout(() => {
        popup.style.opacity = '0';
    }, 2000);
}

function showUndertaleBox(text, options = {}) {
  const box = document.getElementById('undertaleBox');
  const textEl = document.getElementById('undertaleText');
  const inputEl = document.getElementById('undertaleInput');
  const promptEl = document.querySelector('.undertale-prompt');
  const showInput = Boolean(options.showInput);
  const promptText = options.promptText || (showInput ? 'Type and press ENTER' : 'Press ENTER');

  dialogueState.active = true;
  dialogueState.waitingForInput = showInput;

  box.classList.add('show');
  if (showInput) {
    box.classList.add('asking-name');
  } else {
    box.classList.remove('asking-name');
  }
  box.style.borderColor = '#fff';
  box.style.boxShadow = '0 0 0 4px #000, 0 0 40px rgba(255,255,255,0.5)';
  textEl.textContent = '';

  if (showInput) {
    inputEl.value = '';
    setTimeout(() => inputEl.focus(), 50);
  } else {
    inputEl.blur();
  }

  promptEl.style.display = 'block';
  promptEl.textContent = promptText;

  let charIndex = 0;
  if (typewriterInterval) clearInterval(typewriterInterval);

  typewriterInterval = setInterval(() => {
    if (charIndex < text.length) {
      textEl.textContent += text[charIndex];
      charIndex++;

      if (!isMusicMuted && isAudioUnlocked && charIndex % 2 === 0) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = 200;
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.05);
      }
    } else {
      clearInterval(typewriterInterval);
      typewriterInterval = null;
    }
  }, 50);
}

function hideUndertaleBox() {
  const box = document.getElementById('undertaleBox');
  const inputEl = document.getElementById('undertaleInput');
  const promptEl = document.querySelector('.undertale-prompt');

  box.classList.remove('show');
  box.classList.remove('asking-name');
  inputEl.value = '';
  promptEl.style.display = 'none';

  if (typewriterInterval) {
    clearInterval(typewriterInterval);
    typewriterInterval = null;
  }

  resetDialogueState();
}

function showNextDialogue() {
  if (!dialogueState.active) return;
  if (dialogueState.waitingForInput) return;

  const nextIndex = dialogueState.index + 1;

  if (nextIndex >= dialogueState.queue.length) {
    const completion = dialogueState.onComplete;
    hideUndertaleBox();
    if (typeof completion === 'function') completion();
    return;
  }

  dialogueState.index = nextIndex;
  const line = dialogueState.queue[dialogueState.index];
  const shouldAskName = dialogueState.askNameAt === dialogueState.index;

  showUndertaleBox(line, { showInput: shouldAskName });
}

function getNameFollowUpLines(name) {
  if (!name) return ['... silence ... the signal fades ...'];
  const trimmed = name.trim();
  if (!trimmed) return ['... silence ... the signal fades ...'];

  const lower = trimmed.toLowerCase();
  if (lower === 'raj' || lower === 'rajveer') {
    return [
      `... ${trimmed} ... a strange designation ...`,
      'Hey dev!'
    ];
  }
  if (lower === 'jerusha') {
    return [
      `... ${trimmed} ... a strange designation ...`,
      'Special surprises await.'
    ];
  }
  return [
    `... ${trimmed} ... a strange designation ...`,
    `Welcome, ${trimmed}. The journey has just begun.`
  ];
}

function handleNameSubmission() {
  const inputEl = document.getElementById('undertaleInput');
  const promptEl = document.querySelector('.undertale-prompt');
  const rawName = inputEl.value.trim();

  astronaut.name = rawName || null;
  astronautNameKnown = Boolean(astronaut.name);
  inputEl.blur();
  promptEl.textContent = 'Press ENTER';

  let followUpLines;
  if (typeof dialogueState.afterNameLines === 'function') {
    followUpLines = dialogueState.afterNameLines(astronaut.name);
  } else if (Array.isArray(dialogueState.afterNameLines) && dialogueState.afterNameLines.length > 0) {
    followUpLines = dialogueState.afterNameLines.map(line => {
      if (typeof line === 'function') return line(astronaut.name);
      return line;
    });
  } else {
    followUpLines = getNameFollowUpLines(astronaut.name);
  }

  dialogueState.waitingForInput = false;
  dialogueState.askNameAt = null;
  dialogueState.afterNameLines = null;
  dialogueState.queue = Array.isArray(followUpLines) ? [...followUpLines] : [];
  dialogueState.index = -1;

  showNextDialogue();
}

const keys = {};
window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  
  if (dialogueState.active) {
    if (dialogueState.waitingForInput) {
      if (key === 'enter') {
        e.preventDefault();
        handleNameSubmission();
      }
      return;
    }

    if (key === 'enter') {
      e.preventDefault();
      showNextDialogue();
    } else {
      e.preventDefault();
    }
    return;
  }

  // --- Regular game controls (only run if dialogue box is NOT active) ---
  keys[key] = true;
  
  if (key.length === 1) {
    keySequence.push(key);
    if (keySequence.length > GOD_MODE_SEQUENCE.length) {
        keySequence.shift();
    }
    if (keySequence.join('') === GOD_MODE_SEQUENCE) {
        godModeEnabled = !godModeEnabled;
        if (godModeEnabled) ship.fuel = 100;
        showPopup(godModeEnabled ? 'God Mode Enabled' : 'God Mode Disabled');
    }
  }

  if(key === 'r' && gameState !== 'title') reset();
  if(key === 'escape' && gameState !== 'title') {
    // Reset to title screen
    document.getElementById('titleScreen').classList.remove('hidden');
    gameState = 'title';
    
    // Clear and reinitialize splash screen stars
    splashStars = [];
    setupSplashScreen();
    
    // Handle music
    stopTitleMusic();
    startTitleMusic();
  }
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

document.getElementById('soundToggle').addEventListener('click', () => {
  isMusicMuted = !isMusicMuted;
  document.getElementById('soundToggle').textContent = isMusicMuted ? '🔇' : '🔊';
  
  if (isMusicMuted) {
    stopTitleMusic();
    if(sounds.ambience) sounds.ambience.gain.gain.value = 0;
  } else {
    unlockAudio();
    if (gameState === 'title') startTitleMusic();
    if(sounds.ambience) sounds.ambience.gain.gain.value = 0.03;
  }
});

window.addEventListener('resize', () => {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
});

function startGame() {
  unlockAudio();
  stopTitleMusic();
  if (!sounds.thrust) sounds.thrust = createThrustSound();
  if (!sounds.ambience) sounds.ambience = createAmbience();
  
  document.getElementById('titleScreen').classList.add('hidden');
  
  gameState = 'playing';
  ship.x = W/2;
  ship.y = 100;
  ship.vx = 0;
  ship.vy = 0;
  ship.angle = 0;
  ship.fuel = 100;
  ship.thrusting = false;
  ship.throttle = 0;
  ship.legExtension = 0;
  
  camera.x = ship.x - W/2;
  camera.y = 0;
  
  makeTerrain();

    // Clear splash canvas and stars
    const splashCanvas = document.getElementById('splashCanvas');
    if (splashCanvas) {
      const splashCtx = splashCanvas.getContext('2d');
      splashCtx.clearRect(0, 0, splashCanvas.width, splashCanvas.height);
    }
    splashStars = [];
    monolithDialogueSeen = false;
    astronaut.name = null;
  astronautNameKnown = false;
  stuntTracker.lastAngle = 0;
  stuntTracker.accum = 0;
  stuntTracker.cooldown = 0;
}

function reset() {
  ship.x = pad.x + pad.w / 2;
  ship.y = 100;
  ship.vx = Math.random() * 2 - 1;
  ship.vy = 0;
  ship.angle = 0;
  ship.fuel = 100;
  ship.legExtension = 0;
  ship.throttle = 0;
  ship.firstLegTouchTime = null;
  ship.thrusting = false;
  
  astronaut.visible = false;
  camera.x = ship.x - W / 2;
  camera.y = 0;
  fuelPickups.forEach(p => p.collected = false);
  document.getElementById('fuelPacks').textContent = '0';
  document.getElementById('msg').style.display = 'none';
  document.getElementById('controls').innerHTML = 'W/↑ THRUST | A/D ROTATE | R RESTART | ESC MENU';
  hideUndertaleBox();
  monolithDialogueSeen = false;
  astronautNameKnown = Boolean(astronaut.name);
  lily.y = getGroundY(lily.x);
  lily.picked = false;
  lilyPromptShown = false;
  stuntTracker.lastAngle = 0;
  stuntTracker.accum = 0;
  stuntTracker.cooldown = 0;
  gameState = 'playing';
}

function getGroundY(xPos) {
    const wrappedX = ((xPos % TERRAIN_WIDTH) + TERRAIN_WIDTH) % TERRAIN_WIDTH;
    for (let i = 0; i < terrain.length - 1; i++) {
        if (wrappedX >= terrain[i].x && wrappedX <= terrain[i + 1].x) {
            let t = (wrappedX - terrain[i].x) / (terrain[i + 1].x - terrain[i].x);
            return terrain[i].y * (1 - t) + terrain[i + 1].y * t;
        }
    }
    return H;
}

function endGame(msg, success) {
  gameState = success ? 'landed' : 'crashed';
  
  const msgEl = document.getElementById('msg');
  
  // Reset styles first
  msgEl.className = 'msg'; 

  if (success) {
    ship.vy = 0;
    ship.vx = 0;
    
    // Apply a less obtrusive style for success
    msgEl.classList.add('success');

    msgEl.innerHTML = `
      <div style="font-family: 'Press Start 2P', monospace; font-size: 22px; color: #0f0; text-shadow: 0 0 10px #0f0;">
        ${msg}
      </div>
      <div style="font-size: 14px; color: #8f8; font-family: 'Press Start 2P', monospace; margin-top: 10px;">
        PRESS 'O' TO EXPLORE • THRUST TO TAKE-OFF
      </div>`;
    
    if (!firstLandingDone) {
      firstLandingDone = true;
      setTimeout(() => {
        startDialogueSequence(landingDialogues, { context: 'landing' });
      }, 1000);
    }
  } else {
    // Keep the original, intrusive style for crashes
    msgEl.classList.add('crash');
    msgEl.innerHTML = `
      <div style="font-family: 'Press Start 2P', monospace; font-size: 28px; color: #f00; text-shadow: 0 0 10px #f00, 0 0 20px #f00, 0 0 30px #f00; margin-bottom: 15px;">
        ${msg}
      </div>
      <div style="font-size: 14px; color: #f88; text-shadow: 0 0 5px #f00; font-family: 'Press Start 2P', monospace;">
        PRESS 'R' TO RESTART
      </div>`;
  }
  
  msgEl.style.display = 'block';
  if(sounds.thrust) sounds.thrust.gain.gain.value = 0;
}

function updateShip() {
    if (gameState !== 'playing') return;

    // 1. APPLY FORCES (Rotation, Thrust, Gravity)
    if (keys['arrowleft'] || keys['a']) ship.angle -= 0.05;
    if (keys['arrowright'] || keys['d']) ship.angle += 0.05;

    // Normalize angle to [-PI, PI] to measure deltas cleanly
    function normAngle(a){
      while (a > Math.PI) a -= Math.PI * 2;
      while (a <= -Math.PI) a += Math.PI * 2;
      return a;
    }
    const currentAngle = normAngle(ship.angle);
    const prevAngle = stuntTracker.lastAngle;
    let delta = currentAngle - prevAngle;
    // Wrap delta to shortest path
    if (delta > Math.PI) delta -= Math.PI * 2;
    if (delta < -Math.PI) delta += Math.PI * 2;
    stuntTracker.accum += delta;
    stuntTracker.lastAngle = currentAngle;

    // Cooldown prevents spam if spinning continuously
    if (stuntTracker.cooldown > 0) stuntTracker.cooldown--;
    // Check for full rotation (2π). Accumulate multiples without resetting.
    const twoPi = Math.PI * 2;
    if (Math.abs(stuntTracker.accum) >= twoPi && stuntTracker.cooldown === 0) {
      const flips = Math.floor(Math.abs(stuntTracker.accum) / twoPi);
      stuntTracker.cooldown = 60; // ~1s at 60fps
      const label = flips === 1 ? 'FLIP!' : `${flips}x FLIP!`;
      showPopup(label);
      // Don't reset accum here; let it continue accumulating for back-to-back
    }

    ship.thrusting = (keys['arrowup'] || keys['w']) && ship.fuel > 0;

    // Smooth throttle ramp only during takeoff (near ground) to show rocket weight
    const takeoffGroundY = getGroundY(ship.x);
    const isTakeoff = ship.y + 30 >= takeoffGroundY - 5; // Within 5 units of ground
    if (isTakeoff) {
      if (ship.thrusting) {
        ship.throttle += THRUST_RAMP_UP;
      } else {
        ship.throttle -= THRUST_RAMP_DOWN;
      }
      ship.throttle = Math.max(0, Math.min(1, ship.throttle));
    } else {
      // Instant throttle in flight for responsive control
      ship.throttle = ship.thrusting ? 1 : 0;
    }  if (ship.throttle > 0) {
    if (ship.thrusting && !godModeEnabled) {
      ship.fuel -= 0.5 * ship.throttle; // fuel cost proportional to throttle
      if (ship.fuel < 0) ship.fuel = 0;
    }
    const thrustPower = MAX_THRUST_POWER * ship.throttle;
    ship.vx += Math.sin(ship.angle) * thrustPower;
    ship.vy -= Math.cos(ship.angle) * thrustPower;

    if (sounds.thrust && isAudioUnlocked) {
      sounds.thrust.gain.gain.value = !isMusicMuted ? 0.2 * ship.throttle : 0;
      sounds.thrust.filter.frequency.value = 180 + 80 * ship.throttle + Math.random() * 20;
    }
    const flameX = ship.x - Math.sin(ship.angle) * 20;
    const flameY = ship.y + Math.cos(ship.angle) * 20;
    const particleCount = 2 + Math.floor(4 * ship.throttle);
    for (let i = 0; i < particleCount; i++) {
      const particleAngle = ship.angle + (Math.random() - 0.5) * 0.4;
      const speed = 1 + ship.throttle * 4 + Math.random() * 1.5;
      createParticle(flameX, flameY, ship.vx - Math.sin(particleAngle) * speed, ship.vy + Math.cos(particleAngle) * speed, 'rgb(255, 150, 0)');
    }
  } else if (sounds.thrust) {
    sounds.thrust.gain.gain.value = 0;
  }

    ship.vy += SHIP_GRAVITY;
    
    // 2. UPDATE POSITION
    ship.x += ship.vx;
    ship.y += ship.vy;
    ship.x = ((ship.x % TERRAIN_WIDTH) + TERRAIN_WIDTH) % TERRAIN_WIDTH; // World wrapping

    // 3. COLLISION DETECTION
    const groundY = getGroundY(ship.x);
    const shipBottom = ship.y + 30; // Ship height from center to bottom

    if (shipBottom >= groundY) {
        // We've hit the ground
        const vSpeed = Math.abs(ship.vy);
        const hSpeed = Math.abs(ship.vx);
        const angleOK = Math.abs((ship.angle * 180 / Math.PI) % 360) < 15;

        // CRASH DETECTION
        if (vSpeed > 1.5 || hSpeed > 0.8 || !angleOK) {
             let reason = 'CRASHED! ';
             if (vSpeed > 1.5) reason += 'IMPACT TOO HARD';
             else if (hSpeed > 0.8) reason += 'MOVING TOO FAST';
             else reason += 'ANGLE TOO STEEP';
             endGame(reason, false);
             playEffect('crash');
             return;
        }

        // SUCCESSFUL LANDING with natural physics
        ship.y = groundY - 30; // Place ship at ground level
        
        // Apply dampening to simulate landing gear absorbing impact
        ship.vy = ship.vy * -0.2; // Small bounce with dampening
        ship.vx *= 0.8; // Friction
        
        // Once settled (minimal velocity), consider it fully landed
        if (Math.abs(ship.vy) < 0.15 && Math.abs(ship.vx) < 0.1) {
            ship.vy = 0;
            ship.vx = 0;
            ship.angle = 0;
            
            let onPad = ship.x > pad.x && ship.x < pad.x + pad.w;
            endGame(onPad ? 'PERFECT LANDING!' : 'SAFE LANDING!', true);
            playEffect('land');
        }
    } else {
        // No collision, normal flight
        ship.vx *= 0.999;
        ship.vy *= 0.999;
    }

    // 4. UPDATE LEG EXTENSION
    const legY = ship.y + 12 + Math.cos(30 * ship.legExtension * Math.PI/180) * (25 + 20 * ship.legExtension);
    const altitude = getGroundY(ship.x) - legY;
    ship.legExtension = altitude < 150 ? Math.min(1, ship.legExtension + 0.05) : Math.max(0, ship.legExtension - 0.05);

    // 5. Fuel pickup logic - tighter hitbox for better gameplay
    fuelPickups.forEach(pickup => {
        if (!pickup.collected && Math.hypot(ship.x - pickup.x, ship.y - pickup.y) < 20) {
            pickup.collected = true;
            document.getElementById('fuelPacks').textContent = parseInt(document.getElementById('fuelPacks').textContent) + 1;
            showPopup('+1 Fuel Pack');
        }
    });
}

function updateAstronaut() {
  if (keys['arrowleft'] || keys['a']) astronaut.vx = -MOVE_SPEED;
  else if (keys['arrowright'] || keys['d']) astronaut.vx = MOVE_SPEED;
  else astronaut.vx = 0;
  
  astronaut.x += astronaut.vx;

  if (keys[' '] && astronaut.onGround) {
    astronaut.vy = JUMP_FORCE;
    astronaut.onGround = false;
  }

  astronaut.vy += ASTRO_GRAVITY;
  astronaut.y += astronaut.vy;

  const groundY = getGroundY(astronaut.x);
  if (astronaut.y + astronaut.h >= groundY) {
    astronaut.y = groundY - astronaut.h;
    astronaut.vy = 0;
    astronaut.onGround = true;
  } else {
    astronaut.onGround = false;
  }
  
  astronaut.x = ((astronaut.x % TERRAIN_WIDTH) + TERRAIN_WIDTH) % TERRAIN_WIDTH;
  
  fuelPickups.forEach(pickup => {
    if (!pickup.collected && Math.hypot(astronaut.x - pickup.x, astronaut.y - pickup.y) < 15) {
      pickup.collected = true;
      document.getElementById('fuelPacks').textContent = parseInt(document.getElementById('fuelPacks').textContent) + 1;
      showPopup('+1 Fuel Pack');
    }
  });
  
  const dist = Math.hypot(astronaut.x - ship.x, astronaut.y - ship.y);
  if (dist < 50) {
    const fuelPacksCount = parseInt(document.getElementById('fuelPacks').textContent);
    if (fuelPacksCount > 0) {
      ship.fuel = 100;
      document.getElementById('fuelPacks').textContent = '0';
      showPopup('Ship Refueled!');
    }
  }
}

function update(dt) {
  if (gameState === 'title') {
    // Only update splash screen elements
    return;
  }

  // Update background stars
  stars.forEach(s => {
    s.y += s.speed;
    if (s.y > H) { s.y = 0; s.x = Math.random() * W; }
  });

  const controlsEl = document.getElementById('controls');

  // Calculate target camera position
  let targetCamX = 0;
  let targetCamY = 0;

  switch (gameState) {
    case 'playing':
      updateShip();
      // Camera follows ship with smoothing, including when flying high (space)
      targetCamX = ship.x - W / 2;
      // If ship is well above the ground, let camera follow ship.y fully (space effect)
      const groundY = getGroundY(ship.x);
      if (ship.y < groundY - H * 0.6) {
        // In space: camera follows ship.y
        targetCamY = ship.y - H / 2;
      } else {
        // Near moon: camera follows terrain
        targetCamY = Math.min(ship.y - H / 2, groundY - H * 0.8);
      }
      break;
    case 'landed':
      targetCamX = ship.x - W / 2;
      targetCamY = getGroundY(ship.x) - H * 0.8;
      if (keys['arrowup'] || keys['w']) {
        gameState = 'playing';
        ship.vy = -0.5;
        ship.y -= 2;
        document.getElementById('msg').style.display = 'none';
        controlsEl.innerHTML = 'W/↑ THRUST | A/D ROTATE | R RESTART | ESC MENU';
      }
      if (keys['o']) {
        gameState = 'exploring';
        astronaut.visible = true;
        astronaut.x = ship.x + 10;
        astronaut.y = getGroundY(ship.x) - astronaut.h;
        astronaut.onGround = true;
        document.getElementById('msg').style.display = 'none';
        delete keys['o'];
      }
      break;
    case 'exploring':
      updateAstronaut();
      targetCamX = astronaut.x - W / 2;
      targetCamY = getGroundY(astronaut.x) - H * 0.8;
      const dist = Math.hypot(astronaut.x - ship.x, astronaut.y - ship.y);
      if (dist < 50) {
        controlsEl.innerHTML = "Press 'O' to board ship";
        if (keys['o']) {
          gameState = 'landed';
          astronaut.visible = false;
          const onPad = ship.x > pad.x && ship.x < pad.x + pad.w;
          endGame(onPad ? 'PERFECT LANDING!' : 'SAFE LANDING!', true);
          delete keys['o'];
        }
      } else {
        controlsEl.innerHTML = 'A/D or ←/→ MOVE | SPACE JUMP | R RESTART | ESC MENU';
      }
      const monolithDist = Math.hypot(astronaut.x - (monolith.x + monolith.w/2), astronaut.y - (monolith.y + monolith.h/2));
      if (monolithDist < 50 && !dialogueState.active && !monolithDialogueSeen) {
        monolithDialogueSeen = true;
        if (astronautNameKnown) {
          const personalizedLines = [
            monolithDialogues[0],
            ...getNameFollowUpLines(astronaut.name)
          ];
          startDialogueSequence(personalizedLines, { context: 'monolith' });
        } else {
          startDialogueSequence(monolithDialogues, {
            context: 'monolith',
            askNameAt: 1,
            afterNameLines: name => getNameFollowUpLines(name)
          });
        }
      }
      if (monolithDist > 70 && !dialogueState.active) {
        monolithDialogueSeen = false;
      }

      if (!lily.picked) {
        const lilyCenterY = lily.y - 10;
        const lilyDist = Math.hypot(astronaut.x - lily.x, (astronaut.y + astronaut.h / 2) - lilyCenterY);
        if (lilyDist < 40) {
          if (!lilyPromptShown) {
            showPopup("Press 'E' to pick the lily");
            lilyPromptShown = true;
          }
          if (keys['e']) {
            const name = astronaut.name ? astronaut.name.trim().toLowerCase() : '';
            if (name === 'jerusha') {
              lily.picked = true;
              showPopup('The lily warms to your touch. You keep it safe.');
            } else {
              showPopup('Only the chosen one can take this bloom.');
            }
            delete keys['e'];
          }
        } else if (lilyDist > 60) {
          lilyPromptShown = false;
        }
      }
      break;
  }

  // Camera follows smoothly, but speeds up if ship would go off screen
  let CAMERA_SMOOTHING = 0.15;
  
  if (gameState === 'playing') {
    // Check if ship would be off screen with current camera
    const shipScreenY = ship.y - camera.y;
    const shipScreenX = ship.x - camera.x;
    
    // If ship is close to screen edge, follow directly (no lag)
    if (shipScreenY < H * 0.2 || shipScreenY > H * 0.8 || 
        shipScreenX < W * 0.2 || shipScreenX > W * 0.8) {
      CAMERA_SMOOTHING = 1.0; // Instant follow
    } else {
      CAMERA_SMOOTHING = 0.3; // Faster follow during flight
    }
  }
  
  camera.x += (targetCamX - camera.x) * CAMERA_SMOOTHING;
  camera.y += (targetCamY - camera.y) * CAMERA_SMOOTHING;
  
  // Allow camera to follow the ship into space (upwards) but limit how far above the screen it can go
  camera.y = Math.max(-H * 10, camera.y); // Allow scrolling up to 10 screens high

  updateParticles();
}

function drawAstronaut() {
  if (!astronaut.visible) return;
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(astronaut.x, astronaut.y, astronaut.w, astronaut.h - 4);
  ctx.fillRect(astronaut.x - 1, astronaut.y - 6, astronaut.w + 2, 6);
  ctx.fillStyle = '#000000';
  ctx.fillRect(astronaut.x + 4, astronaut.y - 5, 3, 4);
}

function drawWorld() {
  ctx.fillStyle = moonPatternFill;
  ctx.beginPath();
  ctx.moveTo(-1, H);
  terrain.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.lineTo(TERRAIN_WIDTH + 1, H);
  ctx.closePath();
  ctx.fill();
  
  ctx.fillStyle = '#111';
  ctx.fillRect(monolith.x, monolith.y, monolith.w, monolith.h);
  ctx.fillStyle = 'red';
  ctx.globalAlpha = Math.sin(Date.now() * 0.005) * 0.5 + 0.5;
  ctx.fillRect(monolith.x + monolith.w / 2 - 2, monolith.y + 10, 4, 4);
  ctx.globalAlpha = 1;

  ctx.strokeStyle = '#7a7a83';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(terrain[0].x, terrain[0].y);
  for(let i = 1; i < terrain.length; i++) {
      ctx.lineTo(terrain[i].x, terrain[i].y);
  }
  ctx.stroke();
  
  ctx.strokeStyle = '#3a3a43';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(terrain[0].x, terrain[0].y + 2);
  for(let i = 1; i < terrain.length; i++) {
      ctx.lineTo(terrain[i].x, terrain[i].y + 2);
  }
  ctx.stroke();

  fuelPickups.forEach(pickup => {
    if (!pickup.collected) {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.arc(pickup.x, pickup.y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      ctx.stroke();
      if (Math.sin(Date.now() * 0.01) > 0) {
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  });
  
  ctx.fillStyle = '#ffff00';
  ctx.fillRect(pad.x, pad.y, pad.w, 4);
  ctx.fillStyle = '#ff0000';
  ctx.fillRect(pad.x, pad.y - 2, 10, 2);
  ctx.fillRect(pad.x + pad.w - 10, pad.y - 2, 10, 2);
  ctx.fillRect(pad.x + pad.w/2 - 5, pad.y - 2, 10, 2);

  if (!lily.picked) {
    const stemHeight = 16;
    const stemWidth = 2;
    const lilyBaseX = lily.x;
    const lilyBaseY = lily.y;
    ctx.fillStyle = '#1ac36a';
    ctx.fillRect(lilyBaseX - stemWidth / 2, lilyBaseY - stemHeight, stemWidth, stemHeight);
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(lilyBaseX, lilyBaseY - stemHeight, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#f2f2f2';
    ctx.beginPath();
    ctx.arc(lilyBaseX - 3, lilyBaseY - stemHeight + 1, 3, 0, Math.PI * 2);
    ctx.arc(lilyBaseX + 3, lilyBaseY - stemHeight + 1, 3, 0, Math.PI * 2);
    ctx.fill();
  }
  
  if(Math.sin(Date.now() * 0.005) > 0) {
    ctx.fillStyle = '#0f0';
    ctx.beginPath();
    ctx.arc(pad.x + 10, pad.y, 3, 0, Math.PI * 2);
    ctx.arc(pad.x + pad.w - 10, pad.y, 3, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.save();
  ctx.translate(ship.x, ship.y);
  ctx.rotate(ship.angle);
  
  let bodyGradient = ctx.createLinearGradient(0, -36, 0, 15);
  bodyGradient.addColorStop(0, '#fff');
  bodyGradient.addColorStop(0.7, '#ccc');
  bodyGradient.addColorStop(1, '#aaa');
  ctx.fillStyle = bodyGradient;
  
  ctx.beginPath();
  ctx.moveTo(0, -36);
  ctx.lineTo(-20, 15);
  ctx.lineTo(20, 15);
  ctx.closePath();
  ctx.fill();
  
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-10, -20);
  ctx.lineTo(10, -20);
  ctx.moveTo(-15, 0);
  ctx.lineTo(15, 0);
  ctx.stroke();
  
  ctx.fillStyle = '#001144';
  ctx.beginPath();
  ctx.arc(0, -25, 8, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = 'rgba(100, 200, 255, 0.6)';
  ctx.beginPath();
  ctx.arc(-2, -27, 4, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.fillStyle = '#666';
  ctx.fillRect(-22, 5, 4, 8);
  ctx.fillRect(18, 5, 4, 8);
  
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 4;
  
  let legAngle = 30 * ship.legExtension;
  let legLength = 25 + 20 * ship.legExtension;
  
  ctx.beginPath();
  ctx.moveTo(-15, 12);
  let leftLegX = -15 - Math.sin(legAngle * Math.PI/180) * legLength;
  let leftLegY = 12 + Math.cos(legAngle * Math.PI/180) * legLength;
  ctx.lineTo(leftLegX, leftLegY);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(15, 12);
  let rightLegX = 15 + Math.sin(legAngle * Math.PI/180) * legLength;
  let rightLegY = 12 + Math.cos(legAngle * Math.PI/180) * legLength;
  ctx.lineTo(rightLegX, rightLegY);
  ctx.stroke();
  
  if(ship.legExtension > 0.3) {
    ctx.fillStyle = '#444';
    ctx.fillRect(leftLegX - 8, leftLegY - 4, 16, 6);
    ctx.fillStyle = '#666';
    ctx.fillRect(leftLegX - 6, leftLegY - 2, 12, 2);
    
    ctx.fillStyle = '#444';
    ctx.fillRect(rightLegX - 8, rightLegY - 4, 16, 6);
    ctx.fillStyle = '#666';
    ctx.fillRect(rightLegX - 6, rightLegY - 2, 12, 2);
    
    ctx.strokeStyle = '#777';
    ctx.lineWidth = 2;
    for(let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.moveTo(-15 - i * 3, 12 + i * 4);
      ctx.lineTo(leftLegX + i * 2, leftLegY - 4);
      ctx.stroke();
      
      ctx.beginPath();
      ctx.moveTo(15 + i * 3, 12 + i * 4);
      ctx.lineTo(rightLegX - i * 2, rightLegY - 4);
      ctx.stroke();
    }
  }
  
  if(ship.thrusting) {
    let flameGradient = ctx.createRadialGradient(0, 24, 0, 0, 24, 40);
    flameGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
    flameGradient.addColorStop(0.4, 'rgba(255, 150, 0, 0.7)');
    flameGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
    
    ctx.fillStyle = flameGradient;
    let flameSize = 30 + Math.random() * 20;
    ctx.beginPath();
    ctx.moveTo(-10, 20);
    ctx.lineTo(-6, 20 + flameSize);
    ctx.lineTo(0, 20 + flameSize * 1.3);
    ctx.lineTo(6, 20 + flameSize);
    ctx.lineTo(10, 20);
    ctx.fill();
  }
  
  ctx.restore();
}

function draw() {
  // Don't draw game canvas during title screen - splash handles itself
  if (gameState === 'title') return;

  ctx.imageSmoothingEnabled = false;

  ctx.fillStyle = '#050508';
  ctx.fillRect(0, 0, W, H);
  
  ctx.fillStyle = '#fff';
  stars.forEach(s => {
    ctx.globalAlpha = 0.5 + s.size / 4;
    ctx.fillRect(s.x, s.y, s.size, s.size);
  });
  ctx.globalAlpha = 1;

  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  drawWorld();
  ctx.save();
  ctx.translate(-TERRAIN_WIDTH, 0);
  drawWorld();
  ctx.restore();
  ctx.save();
  ctx.translate(TERRAIN_WIDTH, 0);
  drawWorld();
  ctx.restore();

  drawAstronaut();
  drawParticles();

  ctx.restore();
  
  drawRadar();

  document.getElementById('fuel').textContent = godModeEnabled ? '∞' : Math.round(ship.fuel);
  document.getElementById('fuel').className = ship.fuel < 20 && !godModeEnabled ? 'critical' : '';
  let altitude = 0;
  if(gameState === 'exploring') {
    altitude = getGroundY(astronaut.x) - (astronaut.y + astronaut.h);
  } else {
    const legY = ship.y + 12 + Math.cos(30 * ship.legExtension * Math.PI/180) * (25 + 20 * ship.legExtension);
    altitude = getGroundY(ship.x) - legY;
  }
  document.getElementById('alt').textContent = Math.round(altitude);
  document.getElementById('vspeed').textContent = (ship.vy * 50).toFixed(1);
  document.getElementById('hspeed').textContent = (Math.abs(ship.vx) * 50).toFixed(1);
  document.getElementById('angle').textContent = Math.round((ship.angle * 180 / Math.PI) % 360);
}

let lastTime = 0;
function loop(time) {
  let dt = (time - lastTime) / 1000;
  lastTime = time;
  
  // Always update and draw based on game state
  update(dt);
  draw();
  
  requestAnimationFrame(loop);
}

// Reset game state to title
gameState = 'title';

// Initialize game componentsl
makeTerrain();
const patternCanvas = createMoonPattern();
const moonPatternFill = ctx.createPattern(patternCanvas, 'repeat');

// Initialize splash screen
setupSplashScreen();

// Start game loop
requestAnimationFrame(loop);

</script>
</body>
</html>