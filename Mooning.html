<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mooning - Vibe Coded V4</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');
    
    * { margin: 0; padding: 0; }
    body { 
      overflow: hidden; 
      background: #000; 
      font-family: 'Orbitron', monospace;
    }
    canvas { 
        display: block; 
        /* --- CRISP PIXEL ART RENDERING --- */
        image-rendering: -moz-crisp-edges;
        image-rendering: -webkit-crisp-edges;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
    }
    
    .title-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, #000 0%, #0a0a2e 50%, #000 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 1s ease-out;
      overflow: hidden;
    }
    
    .title-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .title {
      font-size: 80px;
      font-weight: 900;
      background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(255,0,255,0.5);
      animation: gradient 3s ease infinite, glow 2s ease-in-out infinite;
      margin-bottom: 20px;
      letter-spacing: 10px;
      z-index: 2;
    }
    
    .subtitle {
      color: #00ffff;
      font-size: 20px;
      margin-bottom: 10px;
      text-shadow: 0 0 10px rgba(0, 255, 255, 1), 0 0 20px rgba(0, 255, 255, 0.7);
      z-index: 2;
    }

    .credits, .start-btn { z-index: 2; }
    
    .credits {
      color: #ff00ff;
      font-size: 16px;
      margin-bottom: 50px;
      text-shadow: 0 0 10px rgba(255,0,255,0.5);
    }
    
    .start-btn {
      padding: 20px 40px;
      font-size: 24px;
      background: transparent;
      color: #00ffff;
      border: 2px solid #00ffff;
      cursor: pointer;
      font-family: 'Orbitron', monospace;
      position: relative;
      overflow: hidden;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 3px;
    }
    
    .start-btn:hover {
      color: #000;
      background: #00ffff;
      box-shadow: 0 0 30px rgba(0,255,255,0.8);
      transform: scale(1.05);
    }
    
    .start-btn:before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255,255,255,0.5);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    
    .start-btn:hover:before {
      width: 300px;
      height: 300px;
    }
    
    @keyframes gradient {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    @keyframes glow {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.2); }
    }
    
    .retro-grid {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 50%;
      background-image: 
        linear-gradient(rgba(255,0,255,0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,0,255,0.1) 1px, transparent 1px);
      background-size: 50px 50px;
      transform: perspective(500px) rotateX(60deg);
      animation: grid-move 2s linear infinite;
      z-index: 1;
    }
    
    .hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: #0f0;
      font-family: 'Orbitron', monospace;
      font-size: 14px;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border: 2px solid #0f0;
      box-shadow: 0 0 20px rgba(0,255,0,0.3);
      z-index: 10;
    }
    
    .hud div { margin: 5px 0; text-shadow: 0 0 5px rgba(0,255,0,0.5); }
    .hud .critical { color: #f00; animation: blink 0.5s infinite; }
    
    @keyframes blink { 50% { opacity: 0.5; } }
    
    .msg {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0ff;
      font-family: 'Orbitron', monospace;
      font-size: 28px;
      text-align: center;
      text-shadow: 0 0 20px rgba(0,255,255,0.8);
      display: none;
      z-index: 10;
    }

    .popup-msg {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 255, 0, 0.8);
        color: #000;
        padding: 10px 20px;
        border-radius: 5px;
        font-size: 16px;
        z-index: 100;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
    }
    
    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      color: #888;
      font-family: 'Orbitron', monospace;
      font-size: 12px;
      text-align: right;
      z-index: 10;
    }

    .sound-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      color: #00ffff;
      font-size: 24px;
      cursor: pointer;
      z-index: 1001;
      opacity: 0.7;
      transition: opacity 0.3s;
    }
    .sound-toggle:hover { opacity: 1; }
  </style>
</head>
<body>
  <div class="title-screen" id="titleScreen">
    <div class="retro-grid"></div>
    <div class="title">MOONING</div>
    <div class="subtitle">VIBE CODED</div>
    <div class="credits">by Rajveer</div>
    <button class="start-btn" onclick="startGame()">START MISSION</button>
    <div class="sound-toggle" id="soundToggle">ðŸ”‡</div>
  </div>
  
  <canvas id="c"></canvas>
  
  <div class="hud">
    <div>FUEL: <span id="fuel">100</span>%</div>
    <div>FUEL PACKS: <span id="fuelPacks">0</span></div>
    <div>ALT: <span id="alt">0</span>m</div>
    <div>V-SPEED: <span id="vspeed">0</span>m/s</div>
    <div>H-SPEED: <span id="hspeed">0</span>m/s</div>
    <div>ANGLE: <span id="angle">0</span>Â°</div>
  </div>
  
  <div class="msg" id="msg"></div>
  <div class="popup-msg" id="popupMsg"></div>
  
  <div class="controls" id="controls">
    W/â†‘ THRUST | A/D ROTATE | R RESTART | ESC MENU
  </div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = window.innerWidth;
let H = canvas.height = window.innerHeight;

// --- NEW & MODIFIED GLOBALS ---
let moonPatternFill;
let godModeEnabled = false;
const keySequence = [];
const GOD_MODE_SEQUENCE = 'god';

// Audio Context
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
let isAudioUnlocked = false;
let isMusicMuted = true; // --- CHANGE: Start muted by default

// Sound generators
const sounds = {
  thrust: null,
  ambience: null,
  music: null,
  crash: null,
  land: null
};

// Particle system
const particles = [];

function createParticle(x, y, vx, vy, color, life = 60) {
  particles.push({ x, y, vx, vy, color, life, maxLife: life });
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    p.vy += 0.1;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.fillStyle = p.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2 + alpha * 3, 0, Math.PI * 2);
    ctx.fill();
  });
}

function unlockAudio() {
    if (!isAudioUnlocked) {
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        isAudioUnlocked = true;
        // Don't start music automatically if muted
        if (!isMusicMuted) {
            startTitleMusic();
        }
        document.body.removeEventListener('click', unlockAudio);
        document.body.removeEventListener('keydown', unlockAudio);
    }
}
document.body.addEventListener('click', unlockAudio);
document.body.addEventListener('keydown', unlockAudio);

function createThrustSound() {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc.type = 'sawtooth';
  osc.frequency.value = 80;
  filter.type = 'lowpass';
  filter.frequency.value = 200;
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  gain.gain.value = 0;
  osc.start();
  return { osc, gain, filter };
}

function createAmbience() {
  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc1.type = 'sine';
  osc1.frequency.value = 60;
  osc2.type = 'sine';
  osc2.frequency.value = 90;
  filter.type = 'lowpass';
  filter.frequency.value = 100;
  filter.Q.value = 15;
  osc1.connect(filter);
  osc2.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  gain.gain.value = isMusicMuted ? 0 : 0.03;
  osc1.start();
  osc2.start();
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  lfo.frequency.value = 0.2;
  lfoGain.gain.value = 10;
  lfo.connect(lfoGain);
  lfoGain.connect(filter.frequency);
  lfo.start();
  return { gain };
}

function createMusic() {
  if (isMusicMuted) return null;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc.type = 'square';
  filter.type = 'lowpass';
  filter.frequency.value = 800;
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  gain.gain.value = 0.05;
  const notes = [110, 130, 165, 130, 110, 98, 110, 130];
  let noteIndex = 0;
  function playNote() {
    osc.frequency.setValueAtTime(notes[noteIndex], audioCtx.currentTime);
    noteIndex = (noteIndex + 1) % notes.length;
  }
  osc.start();
  const interval = setInterval(playNote, 400);
  return { gain, stop: () => { clearInterval(interval); osc.stop(); } };
}

function startTitleMusic() {
  if (sounds.music || isMusicMuted) return;
  sounds.music = createMusic();
}

function stopTitleMusic() {
  if (sounds.music) {
    sounds.music.gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1);
    setTimeout(() => {
      if (sounds.music) {
        sounds.music.stop();
        sounds.music = null;
      }
    }, 1000);
  }
}

function playEffect(type) {
  if (!isAudioUnlocked || isMusicMuted) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);
  if (type === 'crash') {
    osc.type = 'sawtooth';
    osc.frequency.value = 50;
    filter.type = 'lowpass';
    filter.frequency.value = 500;
    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);
    filter.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 1);
    for (let i = 0; i < 30; i++) {
      createParticle(ship.x, ship.y, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, 'rgb(200, 200, 200)');
    }
  } else {
    osc.type = 'sine';
    osc.frequency.value = 400;
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
    osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.5);
  }
  osc.start();
  osc.stop(audioCtx.currentTime + 1.5);
}

// Game State and Entities
let gameState = 'title'; // title, playing, landed, crashed, exploring
const SHIP_GRAVITY = 0.02;
const ASTRO_GRAVITY = 0.05;
const JUMP_FORCE = -2.5;
const MOVE_SPEED = 1.5;

let ship = { x: W/2, y: 100, vx: 0, vy: 0, angle: 0, fuel: 100, thrusting: false, legExtension: 0 };
let astronaut = { x: 0, y: 0, vx: 0, vy: 0, w: 8, h: 16, onGround: false, visible: false };
let camera = { x: 0 };
let terrain = [];
let fuelPickups = [];
let pad = { x: 0, y: 0, w: 120 };
const TERRAIN_WIDTH = W * 5;
const TERRAIN_POINTS = 300;

let stars = [];
for(let i = 0; i < 200; i++) {
  stars.push({ x: Math.random() * W, y: Math.random() * H, size: Math.random() * 2, speed: 0.1 + Math.random() * 0.3 });
}

// --- MORE PIXELATED PATTERN FUNCTION ---
function createMoonPattern() {
    const patternCanvas = document.createElement('canvas');
    const pCtx = patternCanvas.getContext('2d');
    const size = 16; // Smaller canvas for larger perceived pixels
    const pixelSize = 2; // Draw 2x2 blocks for a chunkier feel
    patternCanvas.width = size;
    patternCanvas.height = size;

    const colors = ['#6a6a73', '#878792', '#505059'];
    pCtx.fillStyle = colors[0]; // Base color
    pCtx.fillRect(0, 0, size, size);

    // Draw on a grid for a more intentional pattern
    for (let x = 0; x < size; x += pixelSize * 2) {
        for (let y = 0; y < size; y += pixelSize * 2) {
            if (Math.random() > 0.5) {
                pCtx.fillStyle = colors[Math.floor(Math.random() * 2) + 1];
                pCtx.fillRect(x + (Math.random() - 0.5) * pixelSize, y + (Math.random() - 0.5) * pixelSize, pixelSize, pixelSize);
            }
        }
    }
    return patternCanvas;
}

function makeTerrain() {
  terrain = [];
  fuelPickups = [];
  
  let baseHeight = H * 0.7;
  
  // Use a combination of sines for smooth, rolling hills
  for(let i = 0; i <= TERRAIN_POINTS; i++) {
    let x = (TERRAIN_WIDTH / TERRAIN_POINTS) * i;
    let y = baseHeight + Math.sin(i * 0.3) * 30 + Math.sin(i * 0.7) * 20;
    terrain.push({x, y});
  }
  
  // --- FIX SEAM: Ensure the last point connects perfectly to the first for seamless wrapping ---
  let firstY = baseHeight + Math.sin(0 * 0.3) * 30 + Math.sin(0 * 0.7) * 20;
  terrain[TERRAIN_POINTS] = { x: TERRAIN_WIDTH, y: firstY };

  for(let i = 0; i < 8; i++) {
    const pickupX = Math.random() * TERRAIN_WIDTH;
    const groundY = getGroundY(pickupX);
    fuelPickups.push({ x: pickupX, y: groundY - 10, collected: false });
  }
  
  let padIndex = Math.floor(TERRAIN_POINTS / 10);
  pad.x = terrain[padIndex].x - 60;
  pad.y = terrain[padIndex].y;
  
  for(let i = padIndex - 2; i <= padIndex + 2; i++) {
    if(terrain[i]) terrain[i].y = pad.y;
  }
}

// --- NEW FUNCTION for popups ---
function showPopup(message) {
    const popup = document.getElementById('popupMsg');
    popup.textContent = message;
    popup.style.opacity = '1';
    setTimeout(() => {
        popup.style.opacity = '0';
    }, 2000);
}

const keys = {};
window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  keys[key] = true;
  
  if (key.length === 1) { // Only track single character keys for cheat code
    keySequence.push(key);
    if (keySequence.length > GOD_MODE_SEQUENCE.length) {
        keySequence.shift();
    }
    if (keySequence.join('') === GOD_MODE_SEQUENCE) {
        godModeEnabled = true;
        showPopup('God Mode Enabled');
    }
  }

  if(key === 'r' && gameState !== 'title') reset();
  if(key === 'escape' && gameState !== 'title') {
    document.getElementById('titleScreen').classList.remove('hidden');
    stopTitleMusic();
    startTitleMusic();
    gameState = 'title';
  }
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

document.getElementById('soundToggle').addEventListener('click', () => {
  isMusicMuted = !isMusicMuted;
  document.getElementById('soundToggle').textContent = isMusicMuted ? 'ðŸ”‡' : 'ðŸ”Š';
  
  if (isMusicMuted) {
    stopTitleMusic();
    if(sounds.ambience) sounds.ambience.gain.gain.value = 0;
  } else {
    unlockAudio(); // Important for first click
    if (gameState === 'title') startTitleMusic();
    if(sounds.ambience) sounds.ambience.gain.gain.value = 0.03;
  }
});

window.addEventListener('resize', () => {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
});

function startGame() {
  unlockAudio();
  stopTitleMusic();
  if (!sounds.thrust) sounds.thrust = createThrustSound();
  if (!sounds.ambience) sounds.ambience = createAmbience();
  document.getElementById('titleScreen').classList.add('hidden');
  gameState = 'playing';
  reset();
}

function reset() {
  ship.x = pad.x + pad.w / 2;
  ship.y = 100;
  ship.vx = Math.random() * 2 - 1;
  ship.vy = 0;
  ship.angle = 0;
  ship.fuel = 100;
  ship.legExtension = 0;
  astronaut.visible = false;
  camera.x = ship.x - W / 2;
  fuelPickups.forEach(p => p.collected = false);
  document.getElementById('fuelPacks').textContent = '0';
  document.getElementById('msg').style.display = 'none';
  document.getElementById('controls').innerHTML = 'W/â†‘ THRUST | A/D ROTATE | R RESTART | ESC MENU';
  gameState = 'playing';
}

function getGroundY(xPos) {
    const wrappedX = ((xPos % TERRAIN_WIDTH) + TERRAIN_WIDTH) % TERRAIN_WIDTH;
    for (let i = 0; i < terrain.length - 1; i++) {
        if (wrappedX >= terrain[i].x && wrappedX <= terrain[i + 1].x) {
            let t = (wrappedX - terrain[i].x) / (terrain[i + 1].x - terrain[i].x);
            return terrain[i].y * (1 - t) + terrain[i + 1].y * t;
        }
    }
    return H;
}

function endGame(msg, success) {
  gameState = success ? 'landed' : 'crashed';
  document.getElementById('msg').textContent = success ? msg + " | 'O' to Explore | Thrust to Take-Off" : msg + ' [R to restart]';
  document.getElementById('msg').style.display = 'block';
  document.getElementById('msg').style.color = success ? '#0f0' : '#f00';
  if (success) {
    ship.y = getGroundY(ship.x) - 15; // Set y precisely on the ground
    ship.vy = 0;
    ship.vx = 0;
    ship.angle = 0;
  }
  if(sounds.thrust) sounds.thrust.gain.gain.value = 0;
}

function updateShip() {
  if (keys['arrowleft'] || keys['a']) ship.angle -= 0.05;
  if (keys['arrowright'] || keys['d']) ship.angle += 0.05;
  
  ship.thrusting = (keys['arrowup'] || keys['w']) && ship.fuel > 0;
  
  if(sounds.thrust && isAudioUnlocked) {
    sounds.thrust.gain.gain.value = (ship.thrusting && !isMusicMuted) ? 0.2 : 0;
    if (ship.thrusting) sounds.thrust.filter.frequency.value = 200 + Math.random() * 50;
  }
  
  if(ship.thrusting) {
    if (!godModeEnabled) {
        ship.fuel -= 0.5;
        if (ship.fuel < 0) ship.fuel = 0;
    }
    ship.vx += Math.sin(ship.angle) * 0.1;
    ship.vy -= Math.cos(ship.angle) * 0.1;
    
    const flameX = ship.x + Math.sin(ship.angle) * 8;
    const flameY = ship.y + Math.cos(ship.angle) * 8;
    for (let i = 0; i < 2; i++) {
      createParticle(flameX, flameY, ship.vx + (Math.random() - 0.5) * 2, ship.vy + 1 + Math.random() * 2, 'rgb(255, 150, 0)');
    }
  }
  
  ship.vy += SHIP_GRAVITY;
  ship.vx *= 0.999;
  ship.vy *= 0.999;
  ship.x += ship.vx;
  ship.y += ship.vy;
  ship.x = ((ship.x % TERRAIN_WIDTH) + TERRAIN_WIDTH) % TERRAIN_WIDTH;
  
  const groundY = getGroundY(ship.x);
  const altitude = groundY - ship.y - 15;
  ship.legExtension = altitude < 100 ? Math.min(1, ship.legExtension + 0.1) : Math.max(0, ship.legExtension - 0.1);
  
  if (altitude <= 0) {
    let onPad = ship.x > pad.x && ship.x < pad.x + pad.w;
    let vSpeed = Math.abs(ship.vy);
    let hSpeed = Math.abs(ship.vx);
    let upright = Math.abs(ship.angle) < 0.3;
    
    // --- MODIFIED LANDING LOGIC ---
    if (vSpeed < 1.5 && hSpeed < 0.8 && upright) {
      const message = onPad ? 'PERFECT LANDING!' : 'SAFE LANDING!';
      endGame(message, true);
      playEffect('land');
    } else {
      let reason = !upright ? 'BAD ANGLE' : 'TOO FAST';
      endGame(`CRASHED! ${reason}`, false);
      playEffect('crash');
    }
  }
  
  fuelPickups.forEach(pickup => {
    if (!pickup.collected && Math.hypot(ship.x - pickup.x, ship.y - pickup.y) < 20) {
      pickup.collected = true;
      document.getElementById('fuelPacks').textContent = parseInt(document.getElementById('fuelPacks').textContent) + 1;
    }
  });
}

function updateAstronaut() {
  if (keys['arrowleft'] || keys['a']) astronaut.vx = -MOVE_SPEED;
  else if (keys['arrowright'] || keys['d']) astronaut.vx = MOVE_SPEED;
  else astronaut.vx = 0;
  
  astronaut.x += astronaut.vx;

  if (keys[' '] && astronaut.onGround) {
    astronaut.vy = JUMP_FORCE;
    astronaut.onGround = false;
  }

  astronaut.vy += ASTRO_GRAVITY;
  astronaut.y += astronaut.vy;

  const groundY = getGroundY(astronaut.x);
  if (astronaut.y + astronaut.h >= groundY) {
    astronaut.y = groundY - astronaut.h;
    astronaut.vy = 0;
    astronaut.onGround = true;
  } else {
    astronaut.onGround = false;
  }
  
  astronaut.x = ((astronaut.x % TERRAIN_WIDTH) + TERRAIN_WIDTH) % TERRAIN_WIDTH;
  
  fuelPickups.forEach(pickup => {
    if (!pickup.collected && Math.hypot(astronaut.x - pickup.x, astronaut.y - pickup.y) < 15) {
      pickup.collected = true;
      document.getElementById('fuelPacks').textContent = parseInt(document.getElementById('fuelPacks').textContent) + 1;
    }
  });
  
  const dist = Math.hypot(astronaut.x - ship.x, astronaut.y - ship.y);
  if (dist < 50) {
    const fuelPacksCount = parseInt(document.getElementById('fuelPacks').textContent);
    if (fuelPacksCount > 0) {
      ship.fuel = 100;
      document.getElementById('fuelPacks').textContent = '0';
      const msgEl = document.getElementById('msg');
      msgEl.textContent = 'FUEL DEPOSITED!';
      msgEl.style.display = 'block';
      msgEl.style.color = '#0f0';
      setTimeout(() => {
        if (gameState === 'exploring') msgEl.style.display = 'none';
      }, 2000);
    }
  }
}

function update(dt) {
  stars.forEach(s => {
    s.y += s.speed;
    if (s.y > H) { s.y = 0; s.x = Math.random() * W; }
  });

  updateParticles();
  const controlsEl = document.getElementById('controls');

  switch (gameState) {
    case 'playing':
      updateShip();
      camera.x = ship.x - W / 2;
      break;
    case 'landed':
      if (keys['arrowup'] || keys['w']) {
        gameState = 'playing';
        document.getElementById('msg').style.display = 'none';
        controlsEl.innerHTML = 'W/â†‘ THRUST | A/D ROTATE | R RESTART | ESC MENU';
      }
      if (keys['o']) {
        gameState = 'exploring';
        astronaut.visible = true;
        astronaut.x = ship.x + 10;
        astronaut.y = ship.y - astronaut.h;
        astronaut.onGround = true;
        document.getElementById('msg').style.display = 'none';
        delete keys['o'];
      }
      break;
    case 'exploring':
      updateAstronaut();
      camera.x = astronaut.x - W / 2;
      const dist = Math.hypot(astronaut.x - ship.x, astronaut.y - ship.y);
      if (dist < 50) {
        controlsEl.innerHTML = "Press 'O' to board ship";
        if (keys['o']) {
          gameState = 'landed';
          astronaut.visible = false;
          camera.x = ship.x - W / 2;
          const onPad = ship.x > pad.x && ship.x < pad.x + pad.w;
          const message = onPad ? 'PERFECT LANDING!' : 'SAFE LANDING!';
          document.getElementById('msg').textContent = message + " | 'O' to Explore | Thrust to Take-Off";
          document.getElementById('msg').style.display = 'block';
          delete keys['o'];
        }
      } else {
        controlsEl.innerHTML = 'A/D or â†/â†’ MOVE | SPACE JUMP | R RESTART | ESC MENU';
      }
      break;
  }
}

function drawAstronaut() {
  if (!astronaut.visible) return;
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(astronaut.x, astronaut.y, astronaut.w, astronaut.h - 4);
  ctx.fillRect(astronaut.x - 1, astronaut.y - 6, astronaut.w + 2, 6);
  ctx.fillStyle = '#000000';
  ctx.fillRect(astronaut.x + 4, astronaut.y - 5, 3, 4);
}

function drawWorld() {
  ctx.fillStyle = moonPatternFill;
  ctx.beginPath();
  ctx.moveTo(-1, H); // Start slightly left to prevent seam
  terrain.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.lineTo(TERRAIN_WIDTH + 1, H); // End slightly right
  ctx.closePath();
  ctx.fill();
  
  // Add a highlight to the top edge for a 3D pixel-art effect
  ctx.strokeStyle = '#878792'; // A lighter grey from our pattern
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(terrain[0].x, terrain[0].y);
  for(let i = 1; i < terrain.length; i++) {
      ctx.lineTo(terrain[i].x, terrain[i].y);
  }
  ctx.stroke();

  // Draw fuel pickups
  fuelPickups.forEach(pickup => {
    if (!pickup.collected) {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.arc(pickup.x, pickup.y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      ctx.stroke();
      if (Math.sin(Date.now() * 0.01) > 0) {
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.arc(pickup.x, pickup.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  });
  
  ctx.fillStyle = '#ffff00';
  ctx.fillRect(pad.x, pad.y, pad.w, 4);
  ctx.fillStyle = '#ff0000';
  ctx.fillRect(pad.x, pad.y - 2, 10, 2);
  ctx.fillRect(pad.x + pad.w - 10, pad.y - 2, 10, 2);
  ctx.fillRect(pad.x + pad.w/2 - 5, pad.y - 2, 10, 2);
  
  if(Math.sin(Date.now() * 0.005) > 0) {
    ctx.fillStyle = '#0f0';
    ctx.beginPath();
    ctx.arc(pad.x + 10, pad.y, 3, 0, Math.PI * 2);
    ctx.arc(pad.x + pad.w - 10, pad.y, 3, 0, Math.PI * 2);
    ctx.fill();
  }
  
  ctx.save();
  ctx.translate(ship.x, ship.y);
  ctx.rotate(ship.angle);
  
  let bodyGradient = ctx.createLinearGradient(-8, -12, 8, 12);
  bodyGradient.addColorStop(0, '#fff');
  bodyGradient.addColorStop(1, '#ccc');
  ctx.fillStyle = bodyGradient;
  ctx.beginPath();
  ctx.moveTo(0, -12);
  ctx.lineTo(-8, 10);
  ctx.lineTo(8, 10);
  ctx.closePath();
  ctx.fill();
  
  ctx.fillStyle = '#001144';
  ctx.beginPath();
  ctx.arc(0, -3, 4, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'rgba(100, 200, 255, 0.6)';
  ctx.beginPath();
  ctx.arc(-1, -4, 2, 0, Math.PI * 2);
  ctx.fill();
  
  ctx.strokeStyle = '#888';
  ctx.lineWidth = 2;
  
  let legAngle = 25 * ship.legExtension;
  let legLength = 10 + 8 * ship.legExtension;
  
  ctx.beginPath();
  ctx.moveTo(-6, 8);
  ctx.lineTo(-6 - Math.sin(legAngle * Math.PI/180) * legLength, 8 + Math.cos(legAngle * Math.PI/180) * legLength);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(6, 8);
  ctx.lineTo(6 + Math.sin(legAngle * Math.PI/180) * legLength, 8 + Math.cos(legAngle * Math.PI/180) * legLength);
  ctx.stroke();
  
  if(ship.legExtension > 0.5) {
    ctx.fillStyle = '#444';
    ctx.fillRect(-6 - Math.sin(legAngle * Math.PI/180) * legLength - 3, 8 + Math.cos(legAngle * Math.PI/180) * legLength - 2, 6, 3);
    ctx.fillRect(6 + Math.sin(legAngle * Math.PI/180) * legLength - 3, 8 + Math.cos(legAngle * Math.PI/180) * legLength - 2, 6, 3);
  }
  
  if(ship.thrusting) {
    let flameGradient = ctx.createRadialGradient(0, 12, 0, 0, 12, 20);
    flameGradient.addColorStop(0, 'rgba(255, 255, 200, 0.9)');
    flameGradient.addColorStop(0.4, 'rgba(255, 150, 0, 0.7)');
    flameGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
    
    ctx.fillStyle = flameGradient;
    let flameSize = 15 + Math.random() * 10;
    ctx.beginPath();
    ctx.moveTo(-5, 10);
    ctx.lineTo(-3, 10 + flameSize);
    ctx.lineTo(0, 10 + flameSize * 1.3);
    ctx.lineTo(3, 10 + flameSize);
    ctx.lineTo(5, 10);
    ctx.fill();
  }
  
  ctx.restore();
}

function draw() {
  ctx.imageSmoothingEnabled = false; // Keep pixels crisp

  // --- REMOVED BLUE TINT - SOLID DARK BACKGROUND ---
  ctx.fillStyle = '#050508';
  ctx.fillRect(0, 0, W, H);
  
  ctx.fillStyle = '#fff';
  stars.forEach(s => {
    ctx.globalAlpha = 0.5 + s.size / 4;
    ctx.fillRect(s.x, s.y, s.size, s.size);
  });
  ctx.globalAlpha = 1;

  ctx.save();
  ctx.translate(-camera.x, 0);

  // Draw main world and its two wrapped copies for seamless scrolling
  drawWorld();
  ctx.save();
  ctx.translate(-TERRAIN_WIDTH, 0);
  drawWorld();
  ctx.restore();
  ctx.save();
  ctx.translate(TERRAIN_WIDTH, 0);
  drawWorld();
  ctx.restore();

  drawAstronaut();
  drawParticles();

  ctx.restore();
  
  // Update HUD
  document.getElementById('fuel').textContent = godModeEnabled ? 'âˆž' : Math.round(ship.fuel);
  document.getElementById('fuel').className = ship.fuel < 20 && !godModeEnabled ? 'critical' : '';
  const altitude = gameState === 'exploring' ? getGroundY(astronaut.x) - astronaut.y - astronaut.h : getGroundY(ship.x) - ship.y - 15;
  document.getElementById('alt').textContent = Math.round(altitude);
  document.getElementById('vspeed').textContent = (ship.vy * 50).toFixed(1);
  document.getElementById('hspeed').textContent = (Math.abs(ship.vx) * 50).toFixed(1);
  document.getElementById('angle').textContent = Math.round((ship.angle * 180 / Math.PI) % 360);
}

let lastTime = 0;
function loop(time) {
  let dt = (time - lastTime) / 1000;
  lastTime = time;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// --- INITIALIZATION ---
makeTerrain();
const patternCanvas = createMoonPattern();
moonPatternFill = ctx.createPattern(patternCanvas, 'repeat');
requestAnimationFrame(loop);

</script>
</body>
</html>

